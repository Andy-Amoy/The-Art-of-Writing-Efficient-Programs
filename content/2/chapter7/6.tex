The most important lesson of this chapter is that designing data structures for concurrency is hard, and you should take every opportunity to simplify it. Application-specific restrictions on the use of the data structures can be used to make them both simpler and faster. 

The first decision you must make is which parts of your code need thread safety and which do not. Often, the best solution is to give each thread its own data to work on: any data used by a single thread needs no thread-safety concerns at all. When that is not an option, look for other application-specific restrictions: do you have multiple threads modifying a particular data structure? The implementation is often simpler if there is only one writer thread. Are there any application-specific guarantees you can exploit? Do you know the maximum size of the data structure upfront? Do you need to delete data from the data structure as well as add it at the same time, or can you separate these operations in time? Are there well-defined periods where some data structures are not changing? If so, you do not need any synchronization to read them. These and many other application-specific restrictions can be used to greatly improve the performance of the data structures. 

The second important decision is: what operations on the data structures are you going to support? Another way to restate the last paragraph is "implement the minimal necessary interface." Any interface you do implement must be transactional: each operation must have well-defined behavior for any state of the data structure. Any operation that is valid only if the data structure is in a certain state cannot be safely invoked in a concurrent program unless the caller uses client-side locking to combine multiple operations into a single transaction (in which case, these should probably be one operation in the first place).

The chapter also teaches several ways to implement data structures of different types, as well as the ways to estimate and evaluate their performance. Ultimately, accurate performance measurement can be obtained only in the context of the real application and with the actual data. However, useful approximate benchmarks can save a lot of time during the development and evaluation of potential alternatives. 

This chapter concludes our exploration of concurrency. Next, we go on to learn how the use of the C++ language itself influences the performance of our programs.