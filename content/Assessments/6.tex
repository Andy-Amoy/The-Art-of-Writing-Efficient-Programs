\begin{enumerate}
\item 
A lock-based program, in general, cannot be guaranteed to do useful work toward the end goal at all times. In a lock-free program, at least one thread is guaranteed to make such progress, and in a wait-free program, all threads make progress toward the end goal all the time.

\item 
"Wait-free" should be understood in the algorithmic sense: each thread completes one step of the algorithm and immediately moves on to the next one, and the computed results are never wasted or discarded due to the synchronization between threads. It does not mean that a particular step takes the same time when the computer runs many threads as it does on one thread; the contention for the hardware access is still there

\item 
While the most commonly thought about drawback of locks is their relatively high cost, this is not the main reason to avoid their use: a good algorithm can often reduce the amount of data sharing enough that the cost of the lock itself is not a major issue. The more severe problem is the complexity of managing many locks in a program that needs fine-granularity data synchronization: locking large amounts of data with a single lock means that only one thread can operate on all the locked data, but using many locks for small chunks of data leads to deadlocks, or at least very complex lock management.

\item
The difference is not in the implementation of the counter itself but in the data dependency: a counter has no dependencies and, therefore, does not need to provide any memory order guarantees. An index, on the other hand, should guarantee that the array or the container element indexed by a particular value is visible to a thread when the thread reads this index value.

\item
The key feature of the publishing protocol is that it allows many consumer threads to access the same data without locking while guaranteeing that the data generated by the producer thread is visible to the consumers before they access this data.

\end{enumerate}