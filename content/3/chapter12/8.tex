The last chapter of our book reviews everything we learned about the performance and what determines it, then uses this knowledge to come up with design guidelines for high-performance software systems. We have offered several recommendations for designing interfaces, data organization, components, and modules and described ways to make design decisions informed with good measurement results before we have an implementation whose performance can be measured.

Once again, we must emphasize that design for performance does not automatically yield good performance: it allows for the possibility of a high-performing implementation. The alternative is a performance-hostile design that locks in decisions constraining and preventing efficient code and data structures.

This book has been a journey: we started by learning about the performance of individual hardware components, then studied their interactions with each other and how they influence our use of programming languages. This path led us, at last, to the idea of design for performance. This is the last chapter in the book, but not the last step on your journey: now comes the wide and exciting field of applying your knowledge to practical problems that await you.