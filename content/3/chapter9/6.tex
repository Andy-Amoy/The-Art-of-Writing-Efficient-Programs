In this chapter, we have covered the first of the two large areas of C++ efficiency from the language standpoint: avoiding inefficient language constructs, which boils down to not doing unnecessary work. Many optimization techniques we have studied dovetail with the material we studied earlier, such as the efficiency of accessing memory and avoiding false sharing in concurrent programs. 

The big dilemma every programmer faces is how much work should be invested upfront into writing efficient code and what should be left to incremental optimization. Let us begin by saying that high performance begins at the design stage: designing the architecture and the interfaces that do not lock in poor performance and inefficient implementations is the most important effort in developing high-performance software. 

Beyond that, the distinction should be made between premature optimization and unnecessary pessimization. Creating temporary variables to avoid aliasing is premature unless you have performance measurement data showing that the function you are optimizing contributes greatly to the overall execution time (or unless it improves readability, which is a different matter). Passing large vectors by value until the profiler tells you to change it is just making your code slower for no reason, so it should be avoided from the start. 

The line between the two is not always clear, so you must weigh several factors. You must consider the impact of the change on the program: does it make the code harder to read, more complex, or more difficult to test? Generally, you donâ€™t want to risk making more bugs for the sake of performance unless the measurements tell you that you have to. On the other hand, sometimes more readable or more straightforward code is also more efficient code, then the optimization cannot be considered premature. 

The second major area of C++ efficiency has to do with helping the compiler generate more efficient code. We will cover this in the next chapter.