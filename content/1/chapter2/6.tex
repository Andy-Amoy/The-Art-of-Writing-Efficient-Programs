In this chapter, you have learned perhaps the single most important lesson in the entire book: it makes no sense to talk, or even think, about performance without referring to specific measurements. The rest is largely craftsmanship: we presented several ways to measure performance, starting from the whole program and drilling down to a single line of code.

A large high-performance project will see every tool and method you learned about in this chapter used more than once. Coarse measurements – benchmarking and profiling the entire program or large parts of it – point to the areas of the code that require further investigation. Additional rounds of benchmarking or the collection of a more detailed profile usually follow. Eventually, you will identify the parts of the code that require optimization, and the question becomes, "how do I do this faster?" At this point, you can use a micro-benchmark or another small-scale benchmark to experiment with the code you're optimizing. You may even discover that you don't understand as much as you thought about this code and need a more detailed analysis of its performance; don't forget that you can profile micro-benchmarks!

Eventually, you will have a new version of the performance-critical code that looks favorable in small benchmarks. Still, do not assume anything: now you have to measure the performance of the complete program with your optimizations or enhancements. Sometimes, these measurements will confirm your understanding of the problem and validate its solution. At other times, you will discover that the problem is not what you thought it was, and the optimization, while beneficial by itself, does not have the desired effect on the overall program (it may even make things worse). You now have a new data point, you can compare the profiles of the old and new solutions and look for the answers in the differences this comparison reveals. 

The development and optimization of high-performance programs is almost never a linear, step-by-step process. Instead, it has many iterations of going from a high-level overview to low-level detailed work and back. In this process, there is a role for your intuition; just make sure always to test and confirm your expectations because, when it comes to performance, nothing is truly obvious.

In the next chapter, we will see the solution to the mystery we encountered earlier: removing unnecessary code makes the program slower. In order to do this, we have to understand how to use the CPU efficiently for maximum performance, and the entire next chapter is dedicated to that.