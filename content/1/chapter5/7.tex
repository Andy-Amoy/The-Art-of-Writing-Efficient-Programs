在本章中，我们学习了C++内存模型，以及它给开发者的保证。需要对多线程通过共享数据进行交互时，所发生的详细情况，进行全面的理解。

在多线程程序中，对内存的非同步和无序访问会导致未定义行为，必须不惜任何代价避免。然而，成本通常是通过性能来支付的。虽然我们看重正确性，但当涉及到内存同步时，很容易为正确性付出过高的代价。我们已经了解了管理并发内存访问的不同方法，以及它们的优缺点。最简单的选择是锁定对共享数据的所有访问。另一方面，最复杂的实现使用原子操作，并尽可能少地限制内存序。

性能的第一条规则在这里是完全有效的:性能必须测量，而不是猜测。这对于并发程序来说尤为重要，在并发程序中，由于种种原因，聪明的优化可能无法产生可测量的结果。另一方面，可以保证的一点是，带锁的简单程序更容易编写，而且更有可能是正确的。

有了数据共享对性能影响的理解，就可以更好地理解测量结果，以及在什么时候尝试优化并发内存访问:受内存序限制影响的代码部分越大，放松这些限制就越有可能提高性能。另外，请记住，有些限制来自硬件本身。

总的来说，这比在前面几章中处理的任何内容都要复杂得多(不奇怪，并发通常很难)。下一章将展示在不放弃性能优势的情况下，在程序中如何管理这种复杂性的一些方法。还将看到如何将这里学到的知识，进行实际应用。





